// Generated by CoffeeScript 1.3.3
(function() {
  var ChunkView, RegionRenderer, SCALE, blockInfo, chunks, chunkview, delay, exports, require,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  if (typeof window !== "undefined" && window !== null) {
    require = window.require;
    exports = window.exports;
  }

  SCALE = 5;

  chunks = require('chunk');

  chunkview = require('chunkview');

  ChunkView = chunkview.ChunkView;

  blockInfo = require('blockinfo').blockInfo;

  delay = function(ms, func) {
    return setTimeout(func, ms);
  };

  RegionRenderer = (function() {

    function RegionRenderer(region, options) {
      this.region = region;
      this.options = options;
      this.render = __bind(this.render, this);

      this.animate = __bind(this.animate, this);

      this.onWindowResize = __bind(this.onWindowResize, this);

      this.init = __bind(this.init, this);

      this.showProgress = __bind(this.showProgress, this);

      this.load = __bind(this.load, this);

      this.loadTexture = __bind(this.loadTexture, this);

      this.loadChunk = __bind(this.loadChunk, this);

      this.mcCoordsToWorld = __bind(this.mcCoordsToWorld, this);

      this.addTorches = __bind(this.addTorches, this);

      if (this.options.y < 50) {
        this.options.superflat = true;
      }
      this.mouseX = 0;
      this.mouseY = 0;
      this.textures = {};
      this.windowHalfX = window.innerWidth / 2;
      this.windowHalfY = window.innerHeight / 2;
      this.init();
      this.animate();
      this.load();
    }

    RegionRenderer.prototype.addTorches = function(view) {
      var coords, pointLight, _i, _len, _ref, _results;
      _ref = view.torches;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        coords = _ref[_i];
        pointLight = new THREE.PointLight(0xFFFFAA, 1.0, 15);
        pointLight.position.set(coords[0], coords[1], coords[2]);
        _results.push(this.scene.add(pointLight));
      }
      return _results;
    };

    RegionRenderer.prototype.mcCoordsToWorld = function(x, y, z) {
      var chunkX, chunkZ, posX, posZ, ret, verts;
      posX = x % (32 * 16);
      posZ = z % (32 * 16);
      chunkX = Math.floor(posX / 16);
      chunkZ = Math.floor(posZ / 16);
      posX -= chunkX * 16;
      posZ -= chunkZ * 16;
      verts = chunkview.calcPoint([posX, y, posZ], {
        chunkX: chunkX,
        chunkZ: chunkZ
      });
      ret = {
        x: verts[0],
        y: verts[1],
        z: verts[2],
        chunkX: chunkX,
        chunkZ: chunkZ
      };
      return ret;
    };

    RegionRenderer.prototype.loadChunk = function(chunk, chunkX, chunkZ) {
      var attributes, centerX, centerY, centerZ, geometry, i, material, mesh, options, uvArray, vertexIndexArray, vertexPositionArray, view, _i, _j, _k, _ref, _ref1, _ref2;
      options = {
        nbt: chunk,
        ymin: this.options.ymin,
        showstuff: this.options.showstuff,
        superflat: this.options.superflat,
        chunkX: chunkX,
        chunkZ: chunkZ
      };
      view = new ChunkView(options);
      try {
        view.extractChunk();
      } catch (e) {
        console.log("Error in extractChunk");
        console.log(e);
      }
      if (view.vertices.length === 0) {
        console.log("(" + chunkX + ", " + chunkZ + ") is blank. chunk is ");
        console.log(chunk);
        console.log('view is ');
        console.log(view);
      }
      this.addTorches(view);
      vertexIndexArray = new Uint16Array(view.indices.length);
      for (i = _i = 0, _ref = view.indices.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
        vertexIndexArray[i] = view.indices[i];
      }
      vertexPositionArray = new Float32Array(view.vertices.length);
      for (i = _j = 0, _ref1 = view.vertices.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        vertexPositionArray[i] = view.vertices[i];
      }
      uvArray = new Float32Array(view.textcoords.length);
      for (i = _k = 0, _ref2 = view.textcoords.length; 0 <= _ref2 ? _k < _ref2 : _k > _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        uvArray[i] = view.textcoords[i];
      }
      attributes = {
        index: {
          itemSize: 1,
          array: vertexIndexArray,
          numItems: vertexIndexArray.length
        },
        position: {
          itemSize: 3,
          array: vertexPositionArray,
          numItems: vertexPositionArray.length / 3
        },
        uv: {
          itemSize: 2,
          array: uvArray,
          numItems: uvArray.length / 2
        }
      };
      geometry = new THREE.BufferGeometry();
      geometry.attributes = attributes;
      geometry.offsets = [
        {
          start: 0,
          count: vertexIndexArray.length,
          index: 0
        }
      ];
      geometry.computeBoundingBox();
      geometry.computeBoundingSphere();
      geometry.computeVertexNormals();
      material = this.loadTexture('/terrain.png');
      mesh = new THREE.Mesh(geometry, material);
      mesh.doubleSided = false;
      this.scene.add(mesh);
      centerX = mesh.position.x + 0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
      centerY = mesh.position.y + 0.5 * (geometry.boundingBox.max.y - geometry.boundingBox.min.y);
      centerZ = mesh.position.z + 0.5 * (geometry.boundingBox.max.z - geometry.boundingBox.min.z);
      this.camera.lookAt(mesh.position);
      return null;
    };

    RegionRenderer.prototype.loadTexture = function(path) {
      var image, texture;
      if (this.textures[path]) {
        return this.textures[path];
      }
      image = new Image();
      image.onload = function() {
        return texture.needsUpdate = true;
      };
      image.src = path;
      texture = new THREE.Texture(image, new THREE.UVMapping(), THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, THREE.NearestFilter, THREE.NearestFilter);
      this.textures[path] = new THREE.MeshLambertMaterial({
        map: texture,
        transparent: true
      });
      return this.textures[path];
    };

    RegionRenderer.prototype.load = function() {
      var camPos, chunk, maxx, maxz, minx, minz, region, size, startX, startZ, x, z, _i, _results;
      startX = this.options.x * 1;
      startZ = this.options.z * 1;
      camPos = this.mcCoordsToWorld(startX, this.options.y * 1, startZ);
      size = this.options.size * 1;
      minx = Math.max(camPos.chunkX - (size / 2), 0);
      minz = Math.max(camPos.chunkZ - (size / 2), 0);
      maxx = Math.min(camPos.chunkX + (size / 2), 31);
      maxz = Math.min(camPos.chunkZ + (size / 2), 31);
      this.camera.position.x = camPos.x;
      this.camera.position.y = camPos.y;
      this.camera.position.z = camPos.z;
      console.log('minx is ' + minx + ' and minz is ' + minz);
      _results = [];
      for (x = _i = minx; minx <= maxx ? _i <= maxx : _i >= maxx; x = minx <= maxx ? ++_i : --_i) {
        _results.push((function() {
          var _j, _results1;
          _results1 = [];
          for (z = _j = minz; minz <= maxz ? _j <= maxz : _j >= maxz; z = minz <= maxz ? ++_j : --_j) {
            region = this.region;
            if (true || this.region.hasChunk(x, z)) {
              try {
                chunk = region.getChunk(x, z);
                if (chunk != null) {
                  _results1.push(this.loadChunk(chunk, x, z));
                } else {
                  _results1.push(console.log('chunk at ' + x + ',' + z + ' is undefined'));
                }
              } catch (e) {
                console.log(e.message);
                _results1.push(console.log(e.stack));
              }
            } else {
              _results1.push(void 0);
            }
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    RegionRenderer.prototype.showProgress = function(ratio) {
      return $('#proginner').width(300 * ratio);
    };

    RegionRenderer.prototype.init = function() {
      var container, pointLight;
      container = document.createElement('div');
      document.body.appendChild(container);
      this.clock = new THREE.Clock();
      this.camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 1500);
      this.scene = new THREE.Scene();
      this.scene.add(new THREE.AmbientLight(0x333333));
      pointLight = new THREE.PointLight(0x332222);
      pointLight.position.set(400, 100, 600);
      this.scene.add(pointLight);
      this.renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this.renderer.setClearColorHex(0x6D839C, 1);
      this.renderer.setSize(window.innerWidth, window.innerHeight);
      container.appendChild(this.renderer.domElement);
      this.controls = new THREE.FirstPersonControls(this.camera);
      this.controls.movementSpeed = 20;
      this.controls.lookSpeed = 0.125;
      this.controls.lookVertical = true;
      this.stats = new Stats();
      this.stats.domElement.style.position = 'absolute';
      this.stats.domElement.style.top = '0px';
      container.appendChild(this.stats.domElement);
      return window.addEventListener('resize', this.onWindowResize, false);
    };

    RegionRenderer.prototype.onWindowResize = function() {
      this.windowHalfX = window.innerWidth / 2;
      this.windowHalfY = window.innerHeight / 2;
      this.camera.aspect = window.innerWidth / window.innerHeight;
      this.camera.updateProjectionMatrix();
      this.controls.handleResize();
      return this.renderer.setSize(window.innerWidth, window.innerHeight);
    };

    RegionRenderer.prototype.animate = function() {
      requestAnimationFrame(this.animate);
      this.render();
      return this.stats.update();
    };

    RegionRenderer.prototype.render = function() {
      var time;
      time = Date.now() * 0.00005;
      this.controls.update(this.clock.getDelta());
      return this.renderer.render(this.scene, this.camera);
    };

    return RegionRenderer;

  })();

  exports.RegionRenderer = RegionRenderer;

}).call(this);
